

--- File: ForelagteOpplysningerDbRecord.kt ---

package no.nav.helse.flex.forelagteopplysningerainntekt

import org.postgresql.util.PGobject
import org.springframework.data.annotation.Id
import org.springframework.data.relational.core.mapping.Table
import java.time.Instant

@Table("forelagte_opplysninger_ainntekt")
data class ForelagteOpplysningerDbRecord(
    @Id
    val id: String? = null,
    val fnr: String? = null,
    val vedtaksperiodeId: String,
    val behandlingId: String,
    val forelagteOpplysningerMelding: PGobject,
    val opprettet: Instant,
    val forelagt: Instant?,
)



--- File: ForelagteOpplysningerListener.kt ---

package no.nav.helse.flex.forelagteopplysningerainntekt

import com.fasterxml.jackson.module.kotlin.readValue
import no.nav.helse.flex.logger
import no.nav.helse.flex.objectMapper
import no.nav.helse.flex.vedtaksperiodebehandling.ForelagteOpplysningerMelding
import no.nav.helse.flex.vedtaksperiodebehandling.ForelagteOpplysningerRepository
import org.apache.kafka.clients.consumer.ConsumerRecord
import org.postgresql.util.PGobject
import org.springframework.context.annotation.Profile
import org.springframework.kafka.annotation.KafkaListener
import org.springframework.kafka.support.Acknowledgment
import org.springframework.stereotype.Component
import java.time.Instant

@Component
@Profile("forelagteopplysninger")
class ForelagteOpplysningerListener(
    private val forelagteOpplysningerRepository: ForelagteOpplysningerRepository,
) {
    val log = logger()

    @KafkaListener(
        topics = [FORELAGTE_OPPLYSNINGER_TOPIC],
        containerFactory = "aivenKafkaListenerContainerFactory",
    )
    fun listen(
        cr: ConsumerRecord<String, String>,
        acknowledgment: Acknowledgment,
    ) {
        val valueDeserialisert: ForelagteOpplysningerMelding = objectMapper.readValue(cr.value())

        if (forelagteOpplysningerRepository.existsByVedtaksperiodeIdAndBehandlingId(
                vedtaksperiodeId = valueDeserialisert.vedtaksperiodeId,
                behandlingId = valueDeserialisert.behandlingId,
            )
        ) {
            log.info(
                "Forelagte opplysninger for vedtaksperiode (${valueDeserialisert.vedtaksperiodeId}) " +
                    "og behandlingsid (${valueDeserialisert.behandlingId}) finnes allerede.",
            )
        } else {
            log.info(
                "Lagret forelagte opplysninger melding for vedtaksperiode (${valueDeserialisert.vedtaksperiodeId}) " +
                    "og behandlingsid (${valueDeserialisert.behandlingId})",
            )
            forelagteOpplysningerRepository.save(
                ForelagteOpplysningerDbRecord(
                    id = null,
                    fnr = null,
                    vedtaksperiodeId = valueDeserialisert.vedtaksperiodeId,
                    behandlingId = valueDeserialisert.behandlingId,
                    forelagteOpplysningerMelding =
                        PGobject().also {
                            it.type = "json"
                            it.value = cr.value()
                        },
                    opprettet = Instant.now(),
                    forelagt = null,
                ),
            )
        }
        acknowledgment.acknowledge()
    }
}

const val FORELAGTE_OPPLYSNINGER_TOPIC = "tbd.forelagte-opplysninger"



--- File: ForelagteOpplysningerMelding.kt ---




--- File: HentUsendteMeldingerEtc.kt ---

package no.nav.helse.flex.forelagteopplysningerainntekt

// import no.nav.helse.flex.vedtaksperiodebehandling.ForelagteOpplysningerRepository
import no.nav.helse.flex.vedtaksperiodebehandling.ForelagteOpplysningerRepository
import no.nav.helse.flex.vedtaksperiodebehandling.HentAltForPerson
import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Component
import java.time.Instant
import java.time.temporal.ChronoUnit

@Component
class HentUsendteMeldingerEtc(
    private val kombinerDataService: KombinerDataService,
    private val forelagteOpplysningerRepository: ForelagteOpplysningerRepository,
    private val hentAltForPerson: HentAltForPerson,
) {
    // Schedule the job to run at fixed intervals
    @Scheduled(fixedDelay = 60000) // Runs every 60 seconds (adjust as needed)
    fun runJob() {
        // vedtaksperiodeId er for en periode fom tom, behandlingId er for en vedtaksperiode
        val usendteMeldingerEtc: List<ForelagteOpplysningerDbRecord> = forelagteOpplysningerRepository.findAllByForelagtIsNull()
        val sendteMeldinger: List<ForelagteOpplysningerDbRecord> = forelagteOpplysningerRepository.findAllByForelagtIsNotNull()

        for (usendtMelding in usendteMeldingerEtc) {
            val fnr = usendtMelding.fnr

            val sendteMeldinger = sendteMeldinger.filter { it.fnr == fnr }

            if (fnr != null) {
                val altForPerson = hentAltForPerson.hentAltForPerson(fnr)
            }
        }

            /*
            finn det relevante orgnr:
            @Table(value = "forelagte_opplysninger_ainntekt")
public final data class ForelagteOpplysningerDbRecord(
    val id: String? = null,
    val fnr: String? = null,
    val vedtaksperiodeId: String,
    val behandlingId: String,
    val forelagteOpplysningerMelding: PGobject,
    val opprettet: Instant,
    val forelagt: Instant?
)

             */

        // val kombinerteOpplysninger = kombinerDataService.mergeForelagteOpplysningerWithSykepengesoknad(usendtMelding.vedtaksperiodeId, usendtMelding.behandlingId)

            /*
        public final data class KombinerteData(
    val opplysninger: ForelagteOpplysningerDbRecord,
    val behandling: VedtaksperiodeBehandlingDbRecord,
    val sykepengesoknad: Sykepengesoknad
)
             */

        val fourWeeksAgo = Instant.now().minus(28, ChronoUnit.DAYS)

        for (item in kombinerteOpplysninger) {
            item.opplysninger.forelagt?.let { forelagt ->
                if (forelagt.isBefore(fourWeeksAgo)) {
                    println("True: forelagt timestamp er eldre enn 4 mnd ID: ${item.opplysninger.id}")
                }
            }
        }
    }
}



--- File: KombinerDataService.kt ---

// package no.nav.helse.flex.forelagteopplysningerainntekt
//
// import no.nav.helse.flex.sykepengesoknad.Sykepengesoknad
// import no.nav.helse.flex.sykepengesoknad.SykepengesoknadRepository
// import no.nav.helse.flex.vedtaksperiodebehandling.ForelagteOpplysningerRepository
// import no.nav.helse.flex.vedtaksperiodebehandling.VedtaksperiodeBehandlingDbRecord
// import no.nav.helse.flex.vedtaksperiodebehandling.VedtaksperiodeBehandlingRepository
// import no.nav.helse.flex.vedtaksperiodebehandling.VedtaksperiodeBehandlingSykepengesoknadRepository
// import org.apache.kafka.common.message.ListOffsetsRequestData.ListOffsetsTopic
// import org.springframework.data.annotation.Id
// import org.springframework.stereotype.Service
// import java.time.Instant
// import java.time.LocalDate
//
// // what if you just took fnr and looked directly at sykepengesoknad using fnr?
// @Service
// class KombinerDataService(
//    private val forelagteOpplysningerRepository: ForelagteOpplysningerRepository,
//    private val vedtaksperiodeBehandlingRepository: VedtaksperiodeBehandlingRepository,
//    private val vedtaksperiodeBehandlingSykepengesoknadRepository: VedtaksperiodeBehandlingSykepengesoknadRepository,
//    private val sykepengesoknadRepository: SykepengesoknadRepository
// ) {
//
//    fun mergeForelagteOpplysningerWithSykepengesoknad(forelagteOpplysninger : ForelagteOpplysningerDbRecord): List<KombinerteData> {
//
//
//        /*
//        @Table(value = "forelagte_opplysninger_ainntekt")
// public final data class ForelagteOpplysningerDbRecord(
//    val id: String? = null,
//    val fnr: String? = null,
//    val vedtaksperiodeId: String,
//    val behandlingId: String,
//    val forelagteOpplysningerMelding: PGobject,
//    val opprettet: Instant,
//    val forelagt: Instant?
// )
//         */
//        // val fnr = forelagteOpplysninger.fnr
//
//        val vedtaksperiodeBehandlingId =  vedtaksperiodeBehandlingRepository.findByVedtaksperiodeIdAndBehandlingId(vedtaksperiodeId = forelagteOpplysninger.vedtaksperiodeId, behandlingId = forelagteOpplysninger.behandlingId)!!.id
//
//        val relevanteSykepengesoknadUuider = vedtaksperiodeBehandlingSykepengesoknadRepository.findByVedtaksperiodeBehandlingIdIn(listOf(vedtaksperiodeBehandlingId!!)).map{it.sykepengesoknadUuid}
//
//        val relevanteSykepengesoknader = sykepengesoknadRepository.findBySykepengesoknadUuidIn(relevanteSykepengesoknadUuider)
//
//        val relevanteOrgnr = relevanteSykepengesoknader.map {it.orgnummer }
//
//
//
//
//
//
//
//
//
//
//
//
//        // val relevantSykepengesoknader = if (vedtaksperiodeBehandling?.id != null) vedtaksperiodeBehandlingSykepengesoknadRepository.findByVedtaksperiodeBehandlingIdIn(listOf(vedtaksperiodeBehandling.id)) else emptyList()
//
//
//        // val vedtaksperiodeBehandlingerViaVeBeIder = vedtaksperiodeBehandlingSykepengesoknadRepository.findByVedtaksperiodeBehandlingIdIn(listOf(forelagteOpplysninger.behandlingId)).map(sykepengesoknadRepository)
//
//
//        // val sykepengesoknader = if (fnr != null) sykepengesoknadRepository.findByFnr(fnr) else emptyList()
//
//        // val vedtaksperiodeBehandlinger = if (sykepengesoknader.isNotEmpty()) vedtaksperiodeBehandlingSykepengesoknadRepository.findBySykepengesoknadUuidIn(sykepengesoknader.map { it.sykepengesoknadUuid}) else emptyList()
//
//
//
//
//
//
//
//        /*
//        @Table(value = "vedtaksperiode_behandling")
// public final data class VedtaksperiodeBehandlingDbRecord(
//    val id: String? = null,
//    val opprettetDatabase: Instant,
//    val oppdatertDatabase: Instant,
//    val sisteSpleisstatus: StatusVerdi,
//    val sisteSpleisstatusTidspunkt: Instant,
//    val sisteVarslingstatus: StatusVerdi?,
//    val sisteVarslingstatusTidspunkt: Instant?,
//    val vedtaksperiodeId: String,
//    val behandlingId: String
// )
//         */
//        /
//        /*
//            data class Sykepengesoknad(
//                @Id
//    val id: String? = null,
//                val sykepengesoknadUuid: String,
//                val orgnummer: String?,
//                val soknadstype: String,
//                val startSyketilfelle: LocalDate,
//                val fom: LocalDate,
//                val tom: LocalDate,
//                val fnr: String,
//                val sendt: Instant,
//                val opprettetDatabase: Instant,
// )
// */
// //
// //
// //            val orgnr = sykepengesoknader.map{ it.orgnummer }.distinct()
// //
// //            return sykepengesoknader.map { sykepengesoknad ->
// //                KombinerteData(
// //                    fnr = opplysning.fnr,
// //                    orgnummer = orgnr,
// //                    opplysning = opplysning,
// //                    behandling = behandlingRecord,
// //                    sykepengesoknad = sykepengesoknad
// //                )
// //            }
// //        } else {
// //            return emptyList()
// //        }
// //    }
//    }
// }
//
// data class KombinerteData(
//    val fnr: String?,
//    val orgnummer: List<String?>,
//    val opplysning: ForelagteOpplysningerDbRecord,
//    val behandling: VedtaksperiodeBehandlingDbRecord,
//    val sykepengesoknad: Sykepengesoknad
// )



--- File: SendForelagteOpplysningerCronjob.kt ---

package no.nav.helse.flex.forelagteopplysningerainntekt

import no.nav.helse.flex.logger
import no.nav.helse.flex.sykepengesoknad.SykepengesoknadRepository
import no.nav.helse.flex.util.tilOsloZone
import no.nav.helse.flex.varseltekst.skapForelagteOpplysningerTekst
import no.nav.helse.flex.vedtaksperiodebehandling.*
import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Component
import java.time.DayOfWeek
import java.time.Duration
import java.time.Instant
import java.time.OffsetDateTime
import java.util.concurrent.TimeUnit

@Component
class SendForelagteOpplysningerCronjob(
    private val vedtaksperiodeBehandlingRepository: VedtaksperiodeBehandlingRepository,
    private val forelagteOpplysningerRepository: ForelagteOpplysningerRepository,
    private val hentAltForPerson: HentAltForPerson,
    private val vedtaksperiodeBehandlingSykepengesoknadRepository: VedtaksperiodeBehandlingSykepengesoknadRepository,
    private val sykepengesoknadRepository: SykepengesoknadRepository,
) {
    private val log = logger()

    data class RelevantMeldingInfo(
        val vedtaksperiodeBehandlingId: String,
        val sykepengesoknadUuid: String,
        val orgnummer: String,
    )

    @Scheduled(initialDelay = 1, fixedDelay = 15, timeUnit = TimeUnit.MINUTES)
    fun run(): Map<CronJobStatus, Int> {
        val osloDatetimeNow = OffsetDateTime.now().tilOsloZone()
        if (osloDatetimeNow.dayOfWeek in setOf(DayOfWeek.SUNDAY, DayOfWeek.SATURDAY)) {
            log.info("Det er helg, jobben kjøres ikke")
            return emptyMap()
        }
        if (osloDatetimeNow.hour < 9 || osloDatetimeNow.hour > 15) {
            log.info("Det er ikke dagtid, jobben kjøres ikke")
            return emptyMap()
        }

        return runMedParameter(Instant.now())
    }

    fun runMedParameter(now: OffsetDateTime): Map<CronJobStatus, Int> {
        return runMedParameter(now.toInstant())
    }

    fun runMedParameter(now: Instant): Map<CronJobStatus, Int> {
        log.info("Starter VarselutsendingCronJob")
        val resultat = HashMap<CronJobStatus, Int>()
        val tekstViSender = skapForelagteOpplysningerTekst()

        //        manglendeInntektsmeldingFørsteVarselFinnPersoner.hentOgProsseser(now).also { resultat.putAll(it) }
        //        manglendeInntektsmeldingAndreVarselFinnPersoner.hentOgProsseser(now).also { resultat.putAll(it) }
        //        forsinketSaksbehandlingFørsteVarselFinnPersoner.hentOgProsseser(now).also { resultat.putAll(it) }
        //        forsinketSaksbehandlingRevarselFinnPersoner.hentOgProsseser(now).also { resultat.putAll(it) }

        val usendteMeldinger: List<ForelagteOpplysningerDbRecord> = forelagteOpplysningerRepository.findAllByForelagtIsNull()


        // val altForPerson = hentAltForPerson.hentAltForPerson(usendteMeldinger.first().fnr!!)

        val sendteMeldinger: List<ForelagteOpplysningerDbRecord> = forelagteOpplysningerRepository.findAllByForelagtIsNotNull() // todo bør bare gjelde for siste x mnd

        fun finnOrgNrForMelding(
            melding: ForelagteOpplysningerDbRecord,
        ): List<String>
        {

            val vedtaksperiodeBehandlingId =
                vedtaksperiodeBehandlingRepository.findByVedtaksperiodeIdAndBehandlingId(
                    vedtaksperiodeId = melding.vedtaksperiodeId,
                    behandlingId = melding.behandlingId,
                )!!.id

            val relevanteVedtaksperiodebehandlingSykepengesoknaderRelations =
                vedtaksperiodeBehandlingSykepengesoknadRepository.findByVedtaksperiodeBehandlingId(
                    vedtaksperiodeBehandlingId!!,
                )

            val relevanteSykepengesoknader =
                sykepengesoknadRepository.findBySykepengesoknadUuidIn(
                    relevanteVedtaksperiodebehandlingSykepengesoknaderRelations.map {
                        it.sykepengesoknadUuid
                    },
                )


            val relevanteOrgnr = relevanteSykepengesoknader.mapNotNull{it.orgnummer}

            return relevanteOrgnr
        }



        for (usendtMelding in usendteMeldinger) {
            val fnr = usendtMelding.fnr
            //val orgnummerForMelding = finnOrgNrForMeldinger(usendtMelding)
            if (fnr == null) {
                continue
            }


            // todo finn alle meldinger knyttet til samme person istedenfor, og kutt så ned på dem med disse filtrene samt splitt ut to subsets i form av i usendt og nylig sendt
            // todo should filter for last sent when I make this
//            val nyligSendteMeldingerTilPerson = sendteMeldinger.filter { it.fnr == fnr }.filter {
//                    it.opprettet.isAfter(
//                        now.minus(
//                            Duration.ofDays(28),
//                        ),
//                    )
//                }

            val meldingerTilPerson = forelagteOpplysningerRepository.findByFnrIn(fnr)

            val nyligSendteMeldingerTilPerson = meldingerTilPerson.filter{ it.opprettet != null }. filter {
                it.opprettet.isAfter(
                    now.minus(
                        Duration.ofDays(28),
                    ),
                )
            }

            if (nyligSendteMeldingerTilPerson.isNotEmpty()) {

                val orgnrForUsendtMelding = finnOrgNrForMelding(usendtMelding).firstOrNull()
                val orgnummerForSendtMeldinger = sendteMeldinger.flatMap {finnOrgNrForMelding(it)}

                if (orgnrForUsendtMelding != null && orgnummerForSendtMeldinger.contains(orgnrForUsendtMelding)) {
                    resultat[CronJobStatus.HAR_FATT_NYLIG_VARSEL] = (resultat[CronJobStatus.HAR_FATT_NYLIG_VARSEL] ?: 0) + 1
                } else {
                    // todo send varsel
                }


            } else {
                // todo log no need to check because no recent messages
            }




        }


        log.info(
            "Resultat fra VarselutsendingCronJob: ${
                resultat.map { "${it.key}: ${it.value}" }.sorted().joinToString(
                    separator = "\n",
                    prefix = "\n",
                )
            }",
        )
        return resultat
    }
}

enum class CronJobStatus {
    SENDT_FØRSTE_VARSEL_MANGLER_INNTEKTSMELDING,
    SENDT_ANDRE_VARSEL_MANGLER_INNTEKTSMELDING,
    SENDT_FØRSTE_VARSEL_FORSINKET_SAKSBEHANDLING,
    SENDT_REVARSEL_FORSINKET_SAKSBEHANDLING,

    UNIKE_FNR_KANDIDATER_FØRSTE_MANGLER_INNTEKTSMELDING,
    UNIKE_FNR_KANDIDATER_ANDRE_MANGLER_INNTEKTSMELDING,
    UNIKE_FNR_KANDIDATER_FØRSTE_FORSINKET_SAKSBEHANDLING,

    INGEN_PERIODE_FUNNET_FOR_FØRSTE_MANGLER_INNTEKTSMELDING_VARSEL,
    INGEN_PERIODE_FUNNET_FOR_ANDER_MANGLER_INNTEKTSMELDING_VARSEL,
    INGEN_PERIODE_FUNNET_FOR_FØRSTE_FORSINKET_SAKSBEHANDLING_VARSEL,

    THROTTLET_FØRSTE_MANGLER_INNTEKTSMELDING_VARSEL,
    THROTTLET_ANDRE_MANGLER_INNTEKTSMELDING_VARSEL,
    THROTTLET_FØRSTE_FORSINKER_SAKSBEHANDLING_VARSEL,
    THROTTLET_REVARSEL_FORSINKET_SAKSBEHANDLING_VARSEL,

    VARSLER_IKKE_GRUNNET_FULL_REFUSJON,
    FANT_INGEN_INNTEKTSMELDING,

    HAR_FATT_NYLIG_VARSEL,

    FØRSTE_MANGLER_INNTEKTSMELDING_VARSEL_DRY_RUN,
    ANDRE_MANGLER_INNTEKTSMELDING_VARSEL_DRY_RUN,
    FØRSTE_FORSINKET_SAKSBEHANDLING_VARSEL_DRY_RUN,
    REVARSEL_FORSINKET_SAKSBEHANDLING_VARSEL_DRY_RUN,

    FANT_FLERE_ENN_EN_VEDTAKSPERIODE_FOR_REVARSEL,
    INGEN_PERIODE_FUNNET_FOR_REVARSEL_FORSINKET_SAKSBEHANDLING_VARSEL,
    UNIKE_FNR_KANDIDATER_REVARSEL_FORSINKET_SAKSBEHANDLING,

    VARSLER_ALLEREDE_OM_VENTER_PA_SAKSBEHANDLER,
}



--- File: oldForelagteOpplysningerRepository.kt ---




--- File: output.sick ---
(Skipped (non-matching extension))
